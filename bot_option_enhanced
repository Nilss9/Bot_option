#!/usr/bin/env python3
# bot_option_enhanced.py
"""
Ø¨ÙˆØª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„:
- Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø£Ø³Ø¹Ø§Ø± ÙˆØ³Ù„Ø§Ø³Ù„ Ø®ÙŠØ§Ø±Ø§Øª (yfinance)
- Ø±Ø³Ø§Ø¦Ù„ Ø¹Ø±Ø¨ÙŠØ© (Markdown + Ø£Ø²Ø±Ø§Ø±)
- rate limiting + cache Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Redis (Ø¥Ù† ÙˆÙØ¬Ø¯) Ø£Ùˆ Ø¨Ø¯ÙŠÙ„ Ù…Ù„Ù JSON
- Ø§Ø´ØªØ±Ø§ÙƒØ§Øª /subscribe Ùˆ /unsubscribe
- Scheduler ÙŠØ±Ø³Ù„ ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 10 Ø¯Ù‚Ø§Ø¦Ù‚ Ø®Ù„Ø§Ù„ Ø¬Ù„Ø³Ø© Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ
- ÙŠØ¯Ø¹Ù… broadcast Ø¥Ù…Ø§ Ù„Ù‚Ù†Ø§Ø© (BROADCAST_CHAT_ID) Ø£Ùˆ Ù„ÙƒÙ„ Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ†
"""

import os
import json
import logging
import asyncio
from datetime import datetime, timedelta, time as dtime
from zoneinfo import ZoneInfo

import yfinance as yf
import pandas as pd

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ParseMode,
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# Optional Redis (async)
try:
    import redis.asyncio as redis_async
    REDIS_AVAILABLE = True
except Exception:
    REDIS_AVAILABLE = False

# mibian for Greeks (optional)
try:
    import mibian
    MIBIAN_AVAILABLE = True
except Exception:
    MIBIAN_AVAILABLE = False

# --- Config ---
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
REDIS_URL = os.getenv("REDIS_URL")  # optional. If not provided we'll use file-based storage
BROADCAST_CHAT_ID = os.getenv("BROADCAST_CHAT_ID")  # optional
OWNER_ID = os.getenv("OWNER_ID")  # optional (for admin commands)
CACHE_TTL = int(os.getenv("CACHE_TTL", "60"))
OPTIONS_TTL = int(os.getenv("OPTIONS_TTL", "300"))
RATE_LIMIT = int(os.getenv("RATE_LIMIT", "30"))
RATE_WINDOW = int(os.getenv("RATE_WINDOW", "60"))

if not TELEGRAM_TOKEN:
    raise SystemExit("Please set TELEGRAM_TOKEN environment variable.")

# Logging
logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Storage / Redis or File fallback ---
USE_REDIS = False
redis_client = None
if REDIS_URL and REDIS_AVAILABLE:
    try:
        redis_client = redis_async.from_url(REDIS_URL, decode_responses=True)
        USE_REDIS = True
        logger.info("Using Redis at %s", REDIS_URL)
    except Exception as e:
        logger.exception("Failed to connect to Redis: %s. Falling back to file storage.", e)
        USE_REDIS = False
else:
    if REDIS_URL and not REDIS_AVAILABLE:
        logger.warning("redis.asyncio not installed; REDIS_URL ignored. Using file fallback.")
    USE_REDIS = False

# File-based fallback paths
DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
os.makedirs(DATA_DIR, exist_ok=True)
SUBSCRIBERS_FILE = os.path.join(DATA_DIR, "subscribers.json")
RATE_FILE = os.path.join(DATA_DIR, "rate.json")
CACHE_FILE = os.path.join(DATA_DIR, "cache.json")

# ensure files exist
for f, default in [(SUBSCRIBERS_FILE, []), (RATE_FILE, {}), (CACHE_FILE, {})]:
    if not os.path.exists(f):
        with open(f, "w", encoding="utf-8") as fh:
            json.dump(default, fh)

# --- Major stocks list ---
MAJOR_STOCKS = ["AAPL","MSFT","AMZN","GOOG","NVDA","TSLA","META","BRK-B","JPM","V"]

# --- Helpers: File fallback operations ---
def file_load(path):
    try:
        with open(path, "r", encoding="utf-8") as fh:
            return json.load(fh)
    except Exception:
        return None

def file_save(path, data):
    try:
        with open(path, "w", encoding="utf-8") as fh:
            json.dump(data, fh, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.exception("file_save error: %s", e)

# --- Cache helpers (Redis preferred) ---
async def cache_get(key):
    if USE_REDIS:
        v = await redis_client.get(key)
        if v is None:
            return None
        try:
            return json.loads(v)
        except Exception:
            return v
    else:
        cache = file_load(CACHE_FILE) or {}
        return cache.get(key)

async def cache_set(key, value, ttl=CACHE_TTL):
    if USE_REDIS:
        v = json.dumps(value, default=str)
        await redis_client.set(key, v, ex=ttl)
    else:
        cache = file_load(CACHE_FILE) or {}
        cache[key] = value
        file_save(CACHE_FILE, cache)

# --- Subscribers helpers ---
async def add_subscriber(chat_id):
    if USE_REDIS:
        await redis_client.sadd("subscribers:set", str(chat_id))
    else:
        subs = set(file_load(SUBSCRIBERS_FILE) or [])
        subs.add(str(chat_id))
        file_save(SUBSCRIBERS_FILE, list(subs))

async def remove_subscriber(chat_id):
    if USE_REDIS:
        await redis_client.srem("subscribers:set", str(chat_id))
    else:
        subs = set(file_load(SUBSCRIBERS_FILE) or [])
        subs.discard(str(chat_id))
        file_save(SUBSCRIBERS_FILE, list(subs))

async def list_subscribers():
    if USE_REDIS:
        return await redis_client.smembers("subscribers:set")
    else:
        return set(file_load(SUBSCRIBERS_FILE) or [])

# --- Rate limiting (simple) ---
async def rate_limit_check(user_id):
    key = f"rl:{user_id}"
    if USE_REDIS:
        cur = await redis_client.incr(key)
        if cur == 1:
            await redis_client.expire(key, RATE_WINDOW)
        return cur <= RATE_LIMIT
    else:
        rates = file_load(RATE_FILE) or {}
        now_ts = int(datetime.utcnow().timestamp())
        entry = rates.get(str(user_id), {"count": 0, "start": now_ts})
        # reset if window expired
        if now_ts - entry["start"] > RATE_WINDOW:
            entry = {"count": 1, "start": now_ts}
        else:
            entry["count"] += 1
        rates[str(user_id)] = entry
        file_save(RATE_FILE, rates)
        return entry["count"] <= RATE_LIMIT

# --- yfinance helpers ---
async def fetch_ticker_info(symbol: str):
    key = f"ticker:info:{symbol}"
    cached = await cache_get(key)
    if cached:
        return cached
    tk = yf.Ticker(symbol)
    info = tk.info or {}
    essential = {
        "symbol": info.get("symbol"),
        "shortName": info.get("shortName"),
        "regularMarketPrice": info.get("regularMarketPrice"),
        "previousClose": info.get("previousClose"),
        "dayHigh": info.get("dayHigh"),
        "dayLow": info.get("dayLow"),
        "volume": info.get("volume"),
    }
    await cache_set(key, essential, ttl=CACHE_TTL)
    return essential

async def fetch_expiries(symbol: str):
    key = f"ticker:expiries:{symbol}"
    cached = await cache_get(key)
    if cached:
        return cached
    tk = yf.Ticker(symbol)
    exps = tk.options
    await cache_set(key, exps, ttl=OPTIONS_TTL)
    return exps

async def fetch_option_chain(symbol: str, expiry: str):
    key = f"ticker:chain:{symbol}:{expiry}"
    cached = await cache_get(key)
    if cached:
        return cached
    tk = yf.Ticker(symbol)
    try:
        chain = tk.option_chain(expiry)
        calls = chain.calls.to_dict(orient="records")
        puts = chain.puts.to_dict(orient="records")
        payload = {"calls": calls, "puts": puts}
        await cache_set(key, payload, ttl=OPTIONS_TTL)
        return payload
    except Exception as e:
        logger.exception("Error fetching option chain %s %s: %s", symbol, expiry, e)
        return None

# --- Greeks calculation (optional) ---
def compute_greeks_bs(underlying_price: float, strike: float, days_to_expiry: int, volatility_pct: float, rate_pct: float = 0.0):
    if not MIBIAN_AVAILABLE:
        return None
    try:
        bs = mibian.BS([underlying_price, strike, rate_pct, days_to_expiry], volatility_pct)
        return {
            "delta": getattr(bs, "delta", None),
            "gamma": getattr(bs, "gamma", None),
            "vega": getattr(bs, "vega", None),
            "theta": getattr(bs, "theta", None),
            "rho": getattr(bs, "rho", None),
        }
    except Exception:
        return None

# --- Message formatting ---
def esc(text: str) -> str:
    if text is None:
        return "-"
    return str(text).replace("_", "\\_").replace("-", "\\-").replace(".", "\\.")

def format_price_message(info: dict) -> str:
    symbol = esc(info.get("symbol", "-") or "-")
    name = esc(info.get("shortName", "-") or "-")
    price = info.get("regularMarketPrice")
    prev = info.get("previousClose")
    change = ""
    if price is not None and prev is not None:
        ch = price - prev
        pct = (ch / prev * 100) if prev != 0 else 0
        change = f"{ch:.2f} ({pct:.2f}\\%)"
    msg = (
        f"*{symbol}* â€” _{name}_\n"
        f"*Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ:* `{price}`\n"
        f"*Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³Ø§Ø¨Ù‚:* `{prev}`\n"
    )
    if change:
        msg += f"*Ø§Ù„ØªØºÙŠØ±:* `{change}`\n"
    msg += f"*Ø£Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙˆÙ…:* `{info.get('dayHigh', '-')}`  *Ø£Ø¯Ù†Ù‰ Ø§Ù„ÙŠÙˆÙ…:* `{info.get('dayLow', '-')}`\n"
    msg += f"*Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„:* `{info.get('volume', '-')}`\n"
    return msg

# --- Command Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = "Ù…Ø±Ø­Ø¨Ù‹Ø§! ğŸ‘‹\nØ£Ù†Ø§ Ø¨ÙˆØª Ù„Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¹Ù† Ø£Ø³Ù‡Ù… ÙˆØ£ÙˆØ¨Ø´Ù† Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ.\nØ§Ø³ØªØ®Ø¯Ù… /help Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙˆØ§Ù…Ø±."
    await update.message.reply_text(text)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        (
            "*Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª:*\n"
            "/start â€” Ø¨Ø¯Ø¡\n"
            "/help â€” Ù…Ø³Ø§Ø¹Ø¯Ø©\n"
            "/price SYMBOL â€” Ø³Ø¹Ø± Ø§Ù„Ø³Ù‡Ù…\n"
            "/expiries SYMBOL â€” ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡\n"
            "/chain SYMBOL YYYY-MM-DD â€” Ø³Ù„Ø³Ù„Ø© Ø£ÙˆØ¨Ø´Ù†\n"
            "/option SYMBOL YYYY-MM-DD TYPE STRIKE â€” Ø®ÙŠØ§Ø± Ù…Ø­Ø¯Ø¯\n"
            "/subscribe â€” Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©\n"
            "/unsubscribe â€” Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ\n"
            "/list_subscribers â€” (Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·) Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ†\n\n"
            "ÙˆØ£ÙˆØ§Ù…Ø± Ø³Ø±ÙŠØ¹Ø© Ù„Ù„Ø£Ø³Ù‡Ù… Ø§Ù„ÙƒØ¨Ø±Ù‰ Ù…ØªØ§Ø­Ø© ÙƒØ£ÙˆØ§Ù…Ø±: " + ", ".join([s.lower().replace('-', '_') for s in MAJOR_STOCKS])
        ),
        parse_mode=ParseMode.MARKDOWN,
    )

async def price_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not await rate_limit_check(user.id):
        await update.message.reply_text("ØªØ¬Ø§ÙˆØ²Øª Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.")
        return
    if len(context.args) < 1:
        await update.message.reply_text("Ø§Ù„Ù…Ø±Ø¬Ùˆ ØªÙ…Ø±ÙŠØ± Ø±Ù…Ø² Ø§Ù„Ø³Ù‡Ù…. Ù…Ø«Ø§Ù„: /price AAPL")
        return
    symbol = context.args[0].upper()
    info = await fetch_ticker_info(symbol)
    if not info:
        await update.message.reply_text("Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³Ù‡Ù….")
        return
    text = format_price_message(info)
    kb = [[InlineKeyboardButton("ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ ğŸ—“ï¸", callback_data=f"expiries|{symbol}")]]
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=InlineKeyboardMarkup(kb))

async def expiries_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not await rate_limit_check(user.id):
        await update.message.reply_text("ØªØ¬Ø§ÙˆØ²Øª Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.")
        return
    if len(context.args) < 1:
        await update.message.reply_text("Ø§Ø³ØªØ®Ø¯Ù…: /expiries SYMBOL")
        return
    symbol = context.args[0].upper()
    exps = await fetch_expiries(symbol)
    if not exps:
        await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆØ§Ø±ÙŠØ® Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…ØªØ§Ø­Ø© Ø£Ùˆ Ø§Ù„Ø³Ù‡Ù… ØºÙŠØ± ØµØ­ÙŠØ­.")
        return
    buttons = [[InlineKeyboardButton(e, callback_data=f"chain|{symbol}|{e}")] for e in exps[:12]]
    await update.message.reply_text(f"ØªÙˆØ§Ø±ÙŠØ® Ø§Ù†ØªÙ‡Ø§Ø¡ Ù„Ù„Ø£ÙˆØ¨Ø´Ù† Ù„Ù€ {symbol}:", reply_markup=InlineKeyboardMarkup(buttons))

async def chain_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not await rate_limit_check(user.id):
        await update.message.reply_text("ØªØ¬Ø§ÙˆØ²Øª Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("Ø§Ø³ØªØ®Ø¯Ù…: /chain SYMBOL YYYY-MM-DD")
        return
    symbol = context.args[0].upper()
    expiry = context.args[1]
    payload = await fetch_option_chain(symbol, expiry)
    if not payload:
        await update.message.reply_text("ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø£ÙˆØ¨Ø´Ù†.")
        return
    calls = sorted(payload["calls"], key=lambda r: r.get("openInterest", 0), reverse=True)[:8]
    puts = sorted(payload["puts"], key=lambda r: r.get("openInterest", 0), reverse=True)[:8]
    lines = [f"*{symbol}* â€” Expiry `{expiry}`\n", "*Ø£Ø¹Ù„Ù‰ Calls Ø­Ø³Ø¨ OI:*"]
    for r in calls:
        lines.append(f"`{r['strike']}` bid `{r['bid']}` ask `{r['ask']}` last `{r['lastPrice']}` oi `{int(r.get('openInterest') or 0)}`")
    lines.append("\n*Ø£Ø¹Ù„Ù‰ Puts Ø­Ø³Ø¨ OI:*")
    for r in puts:
        lines.append(f"`{r['strike']}` bid `{r['bid']}` ask `{r['ask']}` last `{r['lastPrice']}` oi `{int(r.get('openInterest') or 0)}`")
    kb = []
    for r in calls[:3]:
        kb.append([InlineKeyboardButton(f"C {r['strike']}", callback_data=f"opt|{symbol}|{expiry}|CALL|{r['strike']}")])
    for r in puts[:3]:
        kb.append([InlineKeyboardButton(f"P {r['strike']}", callback_data=f"opt|{symbol}|{expiry}|PUT|{r['strike']}")])
    await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN, reply_markup=InlineKeyboardMarkup(kb))

async def option_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not await rate_limit_check(user.id):
        await update.message.reply_text("ØªØ¬Ø§ÙˆØ²Øª Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.")
        return
    if len(context.args) < 4:
        await update.message.reply_text("Ø§Ø³ØªØ®Ø¯Ù…: /option SYMBOL YYYY-MM-DD TYPE STRIKE")
        return
    symbol = context.args[0].upper()
    expiry = context.args[1]
    kind = context.args[2].upper()
    try:
        strike = float(context.args[3])
    except Exception:
        await update.message.reply_text("Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³ØªØ±Ø§ÙŠÙƒ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.")
        return
    payload = await fetch_option_chain(symbol, expiry)
    if not payload:
        await update.message.reply_text("ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø£ÙˆØ¨Ø´Ù†.")
        return
    df = pd.DataFrame(payload["calls"] if kind.startswith("C") else payload["puts"])
    if df.empty:
        await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.")
        return
    row = df.loc[df["strike"] == strike]
    note = ""
    if row.empty:
        row = df.iloc[(df["strike"] - strike).abs().argsort()[:1]]
        note = "(Ø£Ù‚Ø±Ø¨ Ø³ØªØ±Ø§ÙŠÙƒ)"
    r = row.iloc[0].to_dict()
    greeks = None
    try:
        info = await fetch_ticker_info(symbol)
        underlying = float(info.get("regularMarketPrice") or 0)
        days = max(1, (datetime.fromisoformat(expiry).date() - datetime.now().date()).days)
        vol = r.get("impliedVolatility") or 0.0
        if vol and vol < 1:
            vol_pct = vol * 100
        else:
            vol_pct = vol if vol else 30.0
        greeks = compute_greeks_bs(underlying, r["strike"], days, vol_pct)
    except Exception:
        greeks = None
    text = (
        f"*{symbol}* {kind} Strike `{r['strike']}` Exp `{expiry}`\n"
        f"Bid: `{r.get('bid')}`  Ask: `{r.get('ask')}`  Last: `{r.get('lastPrice')}`\n"
        f"OI: `{int(r.get('openInterest') or 0)}`  Vol: `{int(r.get('volume') or 0)}`\n"
    )
    if greeks:
        text += "\n*Greeks estimate:*\n"
        text += f"Delta: `{greeks['delta']}`  Gamma: `{greeks['gamma']}`  Vega: `{greeks['vega']}`  Theta: `{greeks['theta']}`\n"
    if note:
        text += f"\n_{note}_"
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

# Callback handler for buttons
async def callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query:
        return
    await query.answer()
    data = query.data or ""
    parts = data.split("|")
    user = update.effective_user
    if not await rate_limit_check(user.id):
        await query.edit_message_text("ØªØ¬Ø§ÙˆØ²Øª Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.")
        return
    if parts[0] == "expiries" and len(parts) == 2:
        symbol = parts[1]
        exps = await fetch_expiries(symbol)
        if not exps:
            await query.edit_message_text("Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø­Ø©.")
            return
        buttons = [[InlineKeyboardButton(e, callback_data=f"chain|{symbol}|{e}")] for e in exps[:12]]
        await query.edit_message_text(f"ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù„Ù€ {symbol}:", reply_markup=InlineKeyboardMarkup(buttons))
    elif parts[0] == "chain" and len(parts) == 3:
        _, symbol, expiry = parts
        payload = await fetch_option_chain(symbol, expiry)
        if not payload:
            await query.edit_message_text("ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø£ÙˆØ¨Ø´Ù†.")
            return
        calls = sorted(payload["calls"], key=lambda r: r.get("openInterest", 0), reverse=True)[:6]
        puts = sorted(payload["puts"], key=lambda r: r.get("openInterest", 0), reverse=True)[:6]
        lines = [f"*{symbol}* â€” Exp `{expiry}`\n"]
        lines.append("*CALLS:*")
        for r in calls:
            lines.append(f"`{r['strike']}` bid `{r['bid']}` ask `{r['ask']}` oi `{int(r.get('openInterest') or 0)}`")
        lines.append("\n*PUTS:*")
        for r in puts:
            lines.append(f"`{r['strike']}` bid `{r['bid']}` ask `{r['ask']}` oi `{int(r.get('openInterest') or 0)}`")
        kb = []
        for r in calls[:3]:
            kb.append([InlineKeyboardButton(f"C {r['strike']}", callback_data=f"opt|{symbol}|{expiry}|CALL|{r['strike']}")])
        for r in puts[:3]:
            kb.append([InlineKeyboardButton(f"P {r['strike']}", callback_data=f"opt|{symbol}|{expiry}|PUT|{r['strike']}")])
        await query.edit_message_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN, reply_markup=InlineKeyboardMarkup(kb))
    elif parts[0] == "opt" and len(parts) == 5:
        _, symbol, expiry, kind, strike = parts
        payload = await fetch_option_chain(symbol, expiry)
        if not payload:
            await query.edit_message_text("ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø£ÙˆØ¨Ø´Ù†.")
            return
        df = pd.DataFrame(payload["calls"] if kind.startswith("C") else payload["puts"])
        if df.empty:
            await query.edit_message_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.")
            return
        row = df.loc[df["strike"] == float(strike)]
        note = ""
        if row.empty:
            row = df.iloc[(df["strike"] - float(strike)).abs().argsort()[:1]]
            note = "(Ø£Ù‚Ø±Ø¨ Ø³ØªØ±Ø§ÙŠÙƒ)"
        r = row.iloc[0].to_dict()
        greeks = None
        try:
            info = await fetch_ticker_info(symbol)
            underlying = float(info.get("regularMarketPrice") or 0)
            days = max(1, (datetime.fromisoformat(expiry).date() - datetime.now().date()).days)
            vol = r.get("impliedVolatility") or 0.0
            if vol and vol < 1:
                vol_pct = vol * 100
            else:
                vol_pct = vol if vol else 30.0
            greeks = compute_greeks_bs(underlying, r["strike"], days, vol_pct)
        except Exception:
            greeks = None
        text = (
            f"*{symbol}* {kind} Strike `{r['strike']}` Exp `{expiry}`\n"
            f"Bid: `{r.get('bid')}`  Ask: `{r.get('ask')}`  Last: `{r.get('lastPrice')}`\n"
            f"OI: `{int(r.get('openInterest') or 0)}`  Vol: `{int(r.get('volume') or 0)}`\n"
        )
        if greeks:
            text += "\n*Greeks estimate:*\n"
            text += f"Delta: `{greeks['delta']}`  Gamma: `{greeks['gamma']}`  Vega: `{greeks['vega']}`  Theta: `{greeks['theta']}`\n"
        if note:
            text += f"\n_{note}_"
        await query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN)
    else:
        await query.edit_message_text("Ø²Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ.")

# Subscription handlers
SUBSCRIBERS_KEY = "subscribers:set"

async def subscribe_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    await add_subscriber(chat_id)
    await update.message.reply_text("ØªÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…. Ø³ØªØµÙ„Ùƒ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø£Ø«Ù†Ø§Ø¡ Ø³Ø§Ø¹Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„.")

async def unsubscribe_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    await remove_subscriber(chat_id)
    await update.message.reply_text("ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ….")

async def list_subscribers_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not OWNER_ID or str(update.effective_user.id) != str(OWNER_ID):
        await update.message.reply_text("Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·.")
        return
    subs = await list_subscribers()
    if not subs:
        await update.message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø­Ø§Ù„ÙŠØ§Ù‹.")
        return
    await update.message.reply_text("Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ†:\n" + "\n".join(sorted(list(subs))))

async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ø§Ù„Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ. Ø§Ø³ØªØ®Ø¯Ù… /help")

# =========== Scheduler (every 10 minutes during NY market hours) ===========
NY_TZ = ZoneInfo("America/New_York")
MARKET_OPEN_NY = dtime(9, 30)
MARKET_CLOSE_NY = dtime(16, 0)
FETCH_INTERVAL_MINUTES = 10

def is_market_open_now():
    now_ny = datetime.now(tz=NY_TZ)
    if now_ny.weekday() >= 5:
        return False
    open_dt = datetime.combine(now_ny.date(), MARKET_OPEN_NY, tzinfo=NY_TZ)
    close_dt = datetime.combine(now_ny.date(), MARKET_CLOSE_NY, tzinfo=NY_TZ)
    return open_dt <= now_ny <= close_dt

async def scheduled_fetch_and_broadcast(app):
    if not is_market_open_now():
        logger.info("Market closed â€” skipping scheduled fetch.")
        return
    results = []
    for sym in MAJOR_STOCKS:
        try:
            info = await fetch_ticker_info(sym)
            price = info.get("regularMarketPrice")
            prev = info.get("previousClose")
            if price is None:
                line = f"{sym}: Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©"
            else:
                ch = price - (prev or 0)
                pct = (ch / prev * 100) if prev else 0
                line = f"{sym}: {price} ({ch:+.2f}, {pct:+.2f}%)"
            results.append(line)
        except Exception:
            results.append(f"{sym}: Ø®Ø·Ø£")
    text = "*ØªØ­Ø¯ÙŠØ« Ø£Ø³ÙˆØ§Ù‚ (ØªÙ„Ù‚Ø§Ø¦ÙŠ)*\n" + "\n".join(results)

    # Prefer BROADCAST_CHAT_ID if provided
    if BROADCAST_CHAT_ID:
        try:
            await app.bot.send_message(chat_id=BROADCAST_CHAT_ID, text=text, parse_mode=ParseMode.MARKDOWN)
            logger.info("Broadcast to BROADCAST_CHAT_ID")
            return
        except Exception:
            logger.exception("Failed to send to BROADCAST_CHAT_ID, will try subscribers.")

    subs = await list_subscribers()
    if not subs:
        logger.info("No subscribers to broadcast.")
        return
    # send in batches of 20 with small delay to avoid hitting telegram rate limits
    subs_list = list(subs)
    batch_size = 20
    for i in range(0, len(subs_list), batch_size):
        batch = subs_list[i:i+batch_size]
        tasks = []
        for chat in batch:
            try:
                tasks.append(app.bot.send_message(chat_id=int(chat), text=text, parse_mode=ParseMode.MARKDOWN))
            except Exception:
                logger.exception("Failed to queue message to %s", chat)
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
        await asyncio.sleep(1)  # small pause between batches

# Scheduler starter
def start_scheduler(app):
    try:
        from apscheduler.schedulers.asyncio import AsyncIOScheduler
    except Exception:
        logger.error("apscheduler missing; scheduler won't run.")
        return
    scheduler = AsyncIOScheduler(timezone="UTC")
    # schedule every FETCH_INTERVAL_MINUTES
    scheduler.add_job(lambda: app.create_task(scheduled_fetch_and_broadcast(app)), "interval", minutes=FETCH_INTERVAL_MINUTES, next_run_time=datetime.utcnow())
    scheduler.start()
    logger.info("Scheduler started: every %s minutes", FETCH_INTERVAL_MINUTES)

# Quick stock handler (e.g. /aapl)
async def quick_stock_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cmd = update.message.text.strip().lstrip("/").split()[0].upper()
    symbol = cmd.replace("_", "-")
    info = await fetch_ticker_info(symbol)
    if not info:
        await update.message.reply_text(f"Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù„Ù€ {symbol}")
        return
    await update.message.reply_text(format_price_message(info), parse_mode=ParseMode.MARKDOWN)

# ============ Main ============
def main():
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    # core handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("price", price_cmd))
    app.add_handler(CommandHandler("expiries", expiries_cmd))
    app.add_handler(CommandHandler("chain", chain_cmd))
    app.add_handler(CommandHandler("option", option_cmd))
    app.add_handler(CommandHandler("subscribe", subscribe_cmd))
    app.add_handler(CommandHandler("unsubscribe", unsubscribe_cmd))
    app.add_handler(CommandHandler("list_subscribers", list_subscribers_cmd))
    app.add_handler(CallbackQueryHandler(callback_handler))
    app.add_handler(MessageHandler(filters.COMMAND, unknown))

    # register quick commands for major stocks
    for sym in MAJOR_STOCKS:
        cmd_name = sym.lower().replace("-", "_")
        app.add_handler(CommandHandler(cmd_name, quick_stock_handler))

    # set bot commands (shortcuts) async
    async def set_commands():
        commands = [
            ("start","Ø¨Ø¯Ø¡"),
            ("help","Ù…Ø³Ø§Ø¹Ø¯Ø©"),
            ("price","Ø³Ø¹Ø± Ø§Ù„Ø³Ù‡Ù…"),
            ("expiries","ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡"),
            ("chain","Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø£ÙˆØ¨Ø´Ù†"),
            ("option","Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø®ÙŠØ§Ø±"),
            ("subscribe","Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ"),
            ("unsubscribe","Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ"),
        ]
        # add quicks
        for s in MAJOR_STOCKS:
            commands.append((s.lower().replace("-","_"), f"Ø³Ø¹Ø± Ø³Ø±ÙŠØ¹ {s}"))
        try:
            await app.bot.set_my_commands([{"command":c,"description":d} for c,d in commands])
        except Exception:
            logger.exception("Failed set_my_commands")

    app.create_task(set_commands())

    # start scheduler
    start_scheduler(app)

    logger.info("Bot starting...")
    app.run_polling()

if __name__ == "__main__":
    main()